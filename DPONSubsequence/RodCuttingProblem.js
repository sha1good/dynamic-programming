// We are given a rod of size ‘N’. It can be cut into pieces.
// Each length of a piece has a particular price given by the price array.
// Our task is to find the maximum revenue that can be generated by selling the rod after cutting( if required) into pieces.

// Problem statement
// Given a rod of length ‘N’ units. The rod can be cut into different sizes and each size has a cost associated with it. Determine the maximum cost obtained by cutting the rod and selling its pieces.

// Note:
// 1. The sizes will range from 1 to ‘N’ and will be integers.

// 2. The sum of the pieces cut should be equal to ‘N’.

// 3. Consider 1-based indexing.
// Detailed explanation ( Input/output format, Notes, Images )
// Constraints:
// 1 <= T <= 50
// 1 <= N <= 100
// 1 <= A[i] <= 100

// Where ‘T’ is the total number of test cases, ‘N’ denotes the length of the rod, and A[i] is the cost of sub-length.

// Time limit: 1 sec.
// Sample Input 1:
// 2
// 5
// 2 5 7 8 10
// 8
// 3 5 8 9 10 17 17 20
// Sample Output 1:
// 12
// 24

function RodCuttingProblemUtil(index, givenRodLength, price, dp) {
  //create the variable and call it rod length, because the rod length must start from 1
  let rodlength = index + 1;

  if (index === 0) {
    return (givenRodLength / rodlength) * price[0];
  }

  if (dp[index][givenRodLength] !== -1) return dp[index][givenRodLength];
  let notTaken =
    0 + RodCuttingProblemUtil(index - 1, givenRodLength, price, dp);
  let taken = Number.MIN_SAFE_INTEGER;

  if (rodlength <= givenRodLength) {
    taken =
      price[index] +
      RodCuttingProblemUtil(index, givenRodLength - rodlength, price, dp);
  }

  return (dp[index][givenRodLength] = Math.max(taken, notTaken));
}

function RodCuttingProblem(givenRodLength, price) {
  let dp = Array.from(Array(givenRodLength), () =>
    Array(givenRodLength + 1).fill(-1)
  );

  return RodCuttingProblemUtil(givenRodLength - 1, givenRodLength, price, dp);
}

let rod = [1, 2, 3, 4, 5];
let n = rod.length;
let givenRodLength = 5;
let price = [2, 5, 7, 8, 10];
let result = RodCuttingProblem(givenRodLength, price);

console.log(result);

function RodCuttingProblemUtilTab(index, givenRodLength, price, dp) {
  // Base Condition: Fill the first row of 'dp' for the first item
  //   for (let i = weight[0]; i <= bagWeight; i++) {
  //     dp[0][i] = value[0];
  //   }

  //OR
  let rodlength = index + 1;
  for (let i = givenRodLength; i >= 0; i--) {
    dp[0][i] = (givenRodLength / rodlength) * price[0];
  }

  // Fill the 'dp' array using bottom-up dynamic programming
  for (let i = 1; i <= index; i++) {
    for (let k = 0; k <= givenRodLength; k++) {
      let taken = Number.MIN_SAFE_INTEGER;
      let notTaken = 0 + dp[i - 1][k];
      if (rodlength <= k) {
        taken = price[i] + dp[i][k - rodlength];
      }

      dp[i][k] = Math.max(notTaken, taken);
    }
  }

  return dp[index][givenRodLength];
}

function RodCuttingProblemTab(rod, givenRodLength, price) {
  // Create a 2D array for dynamic programming
  let dp = Array.from(Array(rod), () => Array(givenRodLength + 1).fill(-1));
  console.log(dp);

  return RodCuttingProblemUtilTab(rod - 1, givenRodLength, price, dp);
}

// Time Complexity: O(N*W)

// Reason: There are two nested loops

// Space Complexity: O(N*W)

// Reason: We are using an external array of size ‘N*W’. Stack Space is eliminated.
let res = RodCuttingProblemTab(n, givenRodLength, price);

console.log(res);
